\documentclass[11pt]{article}

\usepackage{amssymb}

\begin{document}

\section{Background}

\subsection{Syntax}

All labels, i.e., atomic propositions, as well as state names can only consist of letters without numbers and whitespace.
This does not limit they're expressiveness, as a simple transformation of label names does not affect their boolean values.
E.g., \verb|nsoda === 0| is equivalent to \verb|numberOfSodaIsZero|, as both propositions only represent a boolean value.

All formulas require brackets as described in the sections below.
This approach was chosen to avoid ambiguity regarding operator precedence.

\subsection{Transition Systems}

The syntax of transition systems is displayed in the example file \verb|examples/vending-machine.txt|.

The arrow indicates initial states, while dashes indicate regular states.
Each state is automatically labelled by itself, i.e., its name.
Further labels, i.e., atomic propositions, can be specified by appending them to the state name, separated by a colon (see \verb|examples/labels.txt|).

\subsubsection{Validations}

The following transition system validations are implemented:

\begin{itemize}
  \item A transition system must have at least one initial state.
  \item The transitions may only specify defined states.
  \item All states must have an outgoing transition.
\end{itemize}

\subsection{CTL Formulas}

\subsubsection{State Formulas}

\begin{tabular}{l|ll}
  & Formula & Syntax \\
  \hline
  & $true$ & \verb|true| \\
  & $\neg\Phi$ & \verb|!(|$\Phi$\verb|)| \\
  & $\Phi_1 \wedge \Phi_2$ & \verb|(|$\Phi_1$\verb| && |$\Phi_2$\verb|)| \\
  & $\Phi_1 \vee \Phi_2$ & \verb|(|$\Phi_1$\verb[ || [$\Phi_2$\verb|)| \\
  & $\Phi_1 \rightarrow \Phi_2$ & \verb|(|$\Phi_1$\verb| -> |$\Phi_2$\verb|)| \\
  & $\Phi_1 \iff \Phi_2$ & \verb|(|$\Phi_1$\verb| <-> |$\Phi_2$\verb|)| \\
  & $\Phi_1 \oplus \Phi_2$ & \verb|(|$\Phi_1$\verb| xor |$\Phi_2$\verb|)| \\
  & $\exists \Phi$ & \verb|(E |$\Phi$\verb|)| \\
  & $\forall \Phi$ & \verb|(A |$\Phi$\verb|)| \\
\end{tabular}

\subsubsection{Path Formulas}

\begin{tabular}{l|ll}
  & Formula & Syntax \\
  \hline
  & $\Phi_1 \mathcal{U} \Phi_2$ & \verb|(|$\Phi_1$\verb| U |$\Phi_2$\verb|)| \\
  & $\circ \Phi$ & \verb|(X |$\Phi$\verb|)| \\
  & $\diamond \Phi$ & \verb|(F |$\Phi$\verb|)| \\
  & $\square \Phi$ & \verb|(G |$\Phi$\verb|)| \\
\end{tabular}

\subsubsection{Validations}

The following CTL formula validations are implemented:

\begin{itemize}
  \item All atomic propositions used in a formula must be defined in the transition system.
\end{itemize}

\subsection{LTL Formulas}

\begin{tabular}{l|ll}
  & Formula & Syntax \\
  \hline
  & $true$ & \verb|true| \\
  & $\neg\Phi$ & \verb|!(|$\Phi$\verb|)| \\
  & $\Phi_1 \wedge \Phi_2$ & \verb|(|$\Phi_1$\verb| && |$\Phi_2$\verb|)| \\
  & $\Phi_1 \vee \Phi_2$ & \verb|(|$\Phi_1$\verb[ || [$\Phi_2$\verb|)| \\
  & $\Phi_1 \rightarrow \Phi_2$ & \verb|(|$\Phi_1$\verb| -> |$\Phi_2$\verb|)| \\
  & $\Phi_1 \iff \Phi_2$ & \verb|(|$\Phi_1$\verb| <-> |$\Phi_2$\verb|)| \\
  & $\Phi_1 \oplus \Phi_2$ & \verb|(|$\Phi_1$\verb| xor |$\Phi_2$\verb|)| \\
  & $\Phi_1 \mathcal{U} \Phi_2$ & \verb|(|$\Phi_1$\verb| U |$\Phi_2$\verb|)| \\
  & $\circ \Phi$ & \verb|(X |$\Phi$\verb|)| \\
  & $\diamond \Phi$ & \verb|(F |$\Phi$\verb|)| \\
  & $\square \Phi$ & \verb|(G |$\Phi$\verb|)| \\
\end{tabular}

\subsubsection{Validations}

The following LTL formula validations are implemented:

\begin{itemize}
  \item All atomic propositions used in a formula must be defined in the transition system.
\end{itemize}


\section{Development}

\subsection{Build Tool}

The program is implemented using the build tool Cabal (version 3.10.1.0) and GHC (version 9.2.5).
During development, the Haskell Language Server (HSL) (version 1.9.1.0) was used.

\subsubsection{Building}
The executable can be built by invoking the command \verb|cabal build|.
However, installing it with the command \verb|cabal install| is preferable as this approach enables the immediate execution of the program via the CLI.

\subsection{Running}
\label{subsec:dev:running}

Running the program is possible by invoking \verb|cabal run|, or \verb|MiniCheck| if it was installed using \verb|cabal install|.
Appending \verb|--help| prints the help text.
The program has three modes, which are as follows:

\paragraph{minicheck validate TS\_FILE}
Parse and validate the transition system found at \verb|TS_FILE|.

\paragraph{minicheck ctl TS\_FILE CTL\_FORMULA}
Evaluate the CTL formula in the transition system found at \verb|TS_FILE|.

\paragraph{minicheck ltl TS\_FILE LTL\_FORMULA BOUND}
Evaluate the LTL formula in the transition system found at \verb|TS_FILE| with \verb|BOUND| as the maximum path length.

\subsection{Dependencies}

Beyond the \textit{base} and \textit{containers} libraries, which are usually part of the Haskell prelude, this program uses \textit{cmdargs} (version 0.10.22) and \textit{parsec} (version 3.1.16.1).
The former provides functionality for parsing and validating command line arguments, while the latter's monad parser forms the basis of the program's CTL, LTL, and transition system (TS) parsers.

Further, the following language extensions are enabled:

\begin{itemize}
  \item DerivedDataTypeable
  \item InstanceSigs
  \item NamedFieldPuns
\end{itemize}


\subsection{Testing Framework}

The testing framework \textit{hspec} is used to execute unit tests for the CTL, LTL, and TS parsers, as well as the model checker algorithms.

\section{Extension}

This application implemented the bounded LTL model checking extension.
This model checker mode is accessible via the mode described in subsection \ref{subsec:dev:running}.

\section{Modules}

The source code is distributed across the following three directories.

\subsection{app}

This directory contains the application logic that is invoked via the CLI.
It is responsible for argument validation and calling the corresponding library methods.

\subsection{lib}

This directory contains the core logic of the program.
The three sub-directories, CTL, LTL, and TS, each contain modules for their respective models, parsers, and validators.
Further, CTL and LTL also each contain a module for their respective model checking algorithm.
Finally, a Utils model contains common utilities required by multiple other modules. 

\subsection{test}

This directory contains the spec files for the individual modules as well as an entry point for the test execution.

\section{Testing}


All parsers and model checking algorithms have been unit tested.
The tests were used for test-driven development of the respective functionality.
As such, they focus on validating the functionality of a single unit, e.g., a single formula construct.

An expression coverage of 88\% was achieved.
The majority of untested code is the \verb|Show| instance implementation of transition systems. 

\section{Profiling}

% TODO Describe profiling

\section{Known Issues and Limitations}

There are no known issues or limitatons.

\end{document}
